In 2008, a new specification called JAX-RS was defined to simplify RESTful service implementation.
JAX-RS is a framework that focuses on applying Java annotations to plain Java objects.
It has annotations to bind specific URI patterns and HTTP operations to individual
methods of your Java class. It has parameter injection annotations so that you can easily
pull in information from the HTTP request. It has message body readers and writers
that allow you to decouple data format marshalling and unmarshalling from your Java
data objects. It has exception mappers that can map an application-thrown exception
to an HTTP response code and message. Finally, it has some nice facilities for HTTP
content negotiation.

In an Enterprise Java application, the  Customer class would usually be a Java Persistence
(JPA) Entity bean and would be used to interact with a relational database. It could
also be annotated with JAXB annotations that allow you to map a Java class directly to
XML. To keep our example simple,  Customer will be just a plain Java object and stored
in memory. In Chapter 6, I’ll show how you can use JAXB with JAX-RS to make trans-
lating between your customer’s data format (XML) and your  Customer objects easier.

 A JAX-RS service is a Java class that uses JAX-RS annotations to
bind and map specific incoming HTTP requests to Java methods that can service these
requests.

JAX-RS can integrate with popular component models like EJB, Web
Beans, JBoss Seam, and Spring, it does define its own lightweight model.

In vanilla JAX-RS, services can either be singletons or per-request objects. A singleton
means that one and only one Java object services HTTP requests. Per-request means
that a Java object is created to process each incoming request and is thrown away at
the end of that request. Per-request also implies statelessness, as no service state is held
between requests.

To bind HTTP POST requests to the  createCustomer() method, we annotate it
with the  @javax.ws.rs.POST annotation. The  @Path annotation we put on the
CustomerResource class, combined with this  @POST annotation, binds all POST requests
going to the relative URI  /customers to the Java method  createCustomer() .

The  @javax.ws.rs.Consumes annotation applied to  createCustomer() specifies which
media type the method is expecting in the message body of the HTTP input request. If
the client POSTs a media type other than XML, an error code is sent back to the client.

We use an additional  @Path annotation on  getCustomer() to specify which URI will be
bound to the method. The value of this annotation is concatenated with the value of
the  @Path annotation we applied to the  CustomerResource class. This concatenation
defines a URI matching pattern of  /customers/{id} .  {id} matches a URI path segment.
A path segment is any sequence of characters that is not the “/” character.

The  @javax.ws.rs.PathParam annotation tells the JAX-RS provider that
you want to inject a piece of the incoming URI into the parameter.
 In JAX-RS,
any non-JAX-RS-annotated parameter is considered to be a representation of the HTTP
input request’s message body.

Use annotations to control:
-When a method is invoked
-What method should return
-What is passed into the method

 In JAX-RS, you are also allowed to define a Java interface that
contains all your JAX-RS annotation metadata instead of applying all your annotations
to your implementation class

@Consumes("application/xml;charset=utf-8")

@Path can also be applied to your Java method. If you do this, the URI matching pattern
is a concatenation of the class’s  @Path expression and that of the method’s.

@javax.ws.rs.PathParam
This annotation allows you to extract values from URI template parameters.
@javax.ws.rs.MatrixParam
This annotation allows you to extract values from a URI’s matrix parameters.
@javax.ws.rs.QueryParam
This annotation allows you to extract values from a URI’s query parameters.
@javax.ws.rs.FormParam
This annotation allows you to extract values from posted form data.
@javax.ws.rs.HeaderParam
This annotation allows you to extract values from HTTP request headers.
@javax.ws.rs.CookieParam
This annotation allows you to extract values from HTTP cookies set by the client.
@javax.ws.rs.core.Context
This class is the all-purpose injection annotation. It allows you to inject various
helper and informational objects that are provided by the JAX-RS API.
---------------------------------------------------------------------------------
Servers can store state information in cookies on the client, and can retrieve that in-
formation when the client makes its next request. Many web applications use cookies
to set up a session between the client and the server. They also use cookies to remember
identity and user preferences between requests. These cookie values are transmitted
back and forth between the client and server via cookie headers.
----------------------------------------------------------------------------------
Automatic Conversion
JAX-RS can convert this string data into any Java type that you want, provided that it
matches one of the following criteria:
1. It is a primitive type. The  int ,  short ,  float ,  double ,  byte ,  char , and  boolean types
all fit into this category.
2. It is a Java class that has a constructor with a single  String parameter.
3. It is a Java class that has a static method named  valueOf() that takes a single
String argument and returns an instance of the class.
4. It is  a java.util.List<T> ,  java.util.Set<T> , or  java.util.SortedSet<T> , where  T
is a type that satisfies criteria 2 or 3 or is a  String . Examples are  List<Double> ,
Set<String> , or  SortedSet<Integer> .
----------------------------------------------------------------------------------
RFC 6570 - URI Template - IETF Tools

Content Management Interoperability Services (CMIS) Version 1.0
OASIS Standard
3.6.1 URI Templates
----------------------------------------------------------------------------------
Built-in Content Marshalling
JAX-RS has a bunch of built-in handlers that can marshal to and from a few different
specific Java types. While most are low-level conversions, they can still be useful to
your JAX-RS classes
----------------------------------------------------------------------------------
@Pretty
--------------------------------------------------------------------------------
The  ResponseBuilder class is a factory that is used to create one individual  Response
instance. You store up state you want to use to create your response and when you’re
finished, you have the builder instantiate the  Response
----------------------------------------------------------------------------------
http://www.iana.org/assignments/link-relations/link-relations.xhtml

Link Headers for HATEOAS
https://tools.ietf.org/html/draft-nottingham-http-link-header-03

JAX-RS doesn’t have many facilities to help with HATEOAS. HATEOAS is defined by
the application, so there’s not much a framework can add. What it does have, though,
are helper classes that you can use to build the URIs that you link to in your data
formats.
Building URIs with UriBuilder

UriBuilder nextLinkBuilder = uriInfo.getAbsolutePathBuilder();
nextLinkBuilder.queryParam("start", 5);
nextLinkBuilder.queryParam("size", 10);
URI next = nextLinkBuilder.build();
----------------------------------------------------------------------------------
Note that a subresource class like Order often has no root @Path annotations which means that they're delegated to dynamically at runtime, in other words, they can not be invoked upon before one of the root resource classes is invoked first. A root resource class (which has a root @\Path annotation) can become a subresource too if one of its subresource locator methods delegates to it, similar to Order.getItems(productId) above.
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------


StreamingOutput
Response

Customer
Order
    put/post/get/delete

XML or JSON.
Enable HTTPS.
Enable OAuth 2.
----------------------------------------------------------------------------------
RELATED LIBRARIES
HttCommons (Apache Java library for HTTP related functionality. HTTPClient to send requests.)
javax.ws.rs (Base Java:  A collection of built-in priority constants for the JAX-RS components
Jackson (Java library to serialize Java objects to JSON and vice versa. )
Jayway (Company)
------------------------------------------------------------------------------------
PROGRESSION
1. Get XML working
2. Replace strings with string constants from libraries (HTTPHeaders, MediaTypes)
3. Get JSON working (explains mappers/serializers/provider terminology). XML/JSON/... <-> Java objects
4. Get Uber JAR working (edit POM file).
5. Show AWS EC2 micro instance.
6. Copy with SCP (can I make it kill the old server and start the new one?)
7. Open port 80 on ec2 (or port 9000 or whatever)


-------------------------------------------------------------------------------------
HOW OUR THINKING DEVELOPED
First idea was to show CXF implementation of JAX-RS
No Spring. Just embedded Jetty.
Fell apart when we tried to get SSL/TLS working.
How do we make something simple enough to only demonstrate CXF and JAX-RS, but rich enough to be interesting?
Ended up going the Spring Boot route. A lot of stuff is now hidden under the covers, but this approach will get you to working web services faster.

-------------------------------------------------------------------------------------
PAY ATTENTION TO THE LOGS
-Challenging to debug annotation-driven development.
-Look for things like:
    Tomcat initialized with port(s): 8080 (http)
        This tells you what port it is serving up the resources.

    Why doesn't https://localhost:8080/customerservice/hello work?
    Look at the log:
        Mapping servlet: 'CXFServlet' to [/services/*]
    You need to add /services to the head of the path

-------------------------------------------------------------------------------------
 Spring Boot lets you configure HTTP or HTTPS in the application.properties, but not both at once.
 If you want to enable both you will need to configure at least one programmatically.
 The Spring Boot reference documentation recommends configuring HTTPS in the application.properties
  since it’s the more complicated than HTTP.

VULTR SERVER INSTANCE
IP: 104.238.147.53
USER: root

scp -i ~/.ssh/id_desertcodecamp ~/repos/desert-code-camp/server/target/server-1.0-SNAPSHOT.jar root@104.238.147.53:/root/server

ssh -i ~/.ssh/id_desertcodecamp root@104.238.147.53

curl -X GET http://localhost:9000/customerservice/customer/123/
curl -X GET http://104.238.147.53:9000/customer/123/


-------------------------------------------------------------------------------------
keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650

-------------------------------------------------------------------------------------

  private static final Logger logger = LoggerFactory.getLogger(SpringBootLoggingDemo.class);
