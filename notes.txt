In 2008, a new specification called JAX-RS was defined to simplify RESTful service implementation.
JAX-RS is a framework that focuses on applying Java annotations to plain Java objects.
It has annotations to bind specific URI patterns and HTTP operations to individual
methods of your Java class. It has parameter injection annotations so that you can easily
pull in information from the HTTP request. It has message body readers and writers
that allow you to decouple data format marshalling and unmarshalling from your Java
data objects. It has exception mappers that can map an application-thrown exception
to an HTTP response code and message. Finally, it has some nice facilities for HTTP
content negotiation.

In an Enterprise Java application, the  Customer class would usually be a Java Persistence
(JPA) Entity bean and would be used to interact with a relational database. It could
also be annotated with JAXB annotations that allow you to map a Java class directly to
XML. To keep our example simple,  Customer will be just a plain Java object and stored
in memory. In Chapter 6, I’ll show how you can use JAXB with JAX-RS to make trans-
lating between your customer’s data format (XML) and your  Customer objects easier.

 A JAX-RS service is a Java class that uses JAX-RS annotations to
bind and map specific incoming HTTP requests to Java methods that can service these
requests.

JAX-RS can integrate with popular component models like EJB, Web
Beans, JBoss Seam, and Spring, it does define its own lightweight model.

In vanilla JAX-RS, services can either be singletons or per-request objects. A singleton
means that one and only one Java object services HTTP requests. Per-request means
that a Java object is created to process each incoming request and is thrown away at
the end of that request. Per-request also implies statelessness, as no service state is held
between requests.

To bind HTTP POST requests to the  createCustomer() method, we annotate it
with the  @javax.ws.rs.POST annotation. The  @Path annotation we put on the
CustomerResource class, combined with this  @POST annotation, binds all POST requests
going to the relative URI  /customers to the Java method  createCustomer() .

The  @javax.ws.rs.Consumes annotation applied to  createCustomer() specifies which
media type the method is expecting in the message body of the HTTP input request. If
the client POSTs a media type other than XML, an error code is sent back to the client.

We use an additional  @Path annotation on  getCustomer() to specify which URI will be
bound to the method. The value of this annotation is concatenated with the value of
the  @Path annotation we applied to the  CustomerResource class. This concatenation
defines a URI matching pattern of  /customers/{id} .  {id} matches a URI path segment.
A path segment is any sequence of characters that is not the “/” character.

The  @javax.ws.rs.PathParam annotation tells the JAX-RS provider that
you want to inject a piece of the incoming URI into the parameter.
 In JAX-RS,
any non-JAX-RS-annotated parameter is considered to be a representation of the HTTP
input request’s message body.

Use annotations to control:
-When a method is invoked
-What method should return
-What is passed into the method





 In JAX-RS, you are also allowed to define a Java interface that
contains all your JAX-RS annotation metadata instead of applying all your annotations
to your implementation class

@Consumes("application/xml;charset=utf-8")

@Path can also be applied to your Java method. If you do this, the URI matching pattern
is a concatenation of the class’s  @Path expression and that of the method’s.

@javax.ws.rs.PathParam
This annotation allows you to extract values from URI template parameters.
@javax.ws.rs.MatrixParam
This annotation allows you to extract values from a URI’s matrix parameters.
@javax.ws.rs.QueryParam
This annotation allows you to extract values from a URI’s query parameters.
@javax.ws.rs.FormParam
This annotation allows you to extract values from posted form data.
@javax.ws.rs.HeaderParam
This annotation allows you to extract values from HTTP request headers.
@javax.ws.rs.CookieParam
This annotation allows you to extract values from HTTP cookies set by the client.
@javax.ws.rs.core.Context
This class is the all-purpose injection annotation. It allows you to inject various
helper and informational objects that are provided by the JAX-RS API.

StreamingOutput
Response

Customer
Order
    put/post/get/delete

XML or JSON.
Enable HTTPS.
Enable OAuth 2.

RELATED LIBRARIES
HttCommons (Apache Java library for HTTP related functionality. HTTPClient to send requests.)
javax.ws.rs (Base Java:  A collection of built-in priority constants for the JAX-RS components
Jackson (Java library to serialize Java objects to JSON and vice versa. )
Jayway (Company)

PROGRESSION
1. Get XML working
2. Replace strings with string constants from libraries (HTTPHeaders, MediaTypes)
3. Get JSON working (explains mappers/serializers/provider terminology). XML/JSON/... <-> Java objects
4. Get Uber JAR working (edit POM file).
5. Show AWS EC2 micro instance.
6. Copy with SCP (can I make it kill the old server and start the new one?)
7. Open port 80 on ec2 (or port 9000 or whatever)


VULTR SERVER INSTANCE
IP: 104.238.147.53
USER: root

scp -i ~/.ssh/id_desertcodecamp ~/repos/desert-code-camp/server/target/server-1.0-SNAPSHOT.jar root@104.238.147.53:/root/server

ssh -i ~/.ssh/id_desertcodecamp root@104.238.147.53

curl -X GET http://localhost:9000/customerservice/customer/123/
curl -X GET http://104.238.147.53:9000/customer/123/
